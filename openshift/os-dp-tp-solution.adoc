---
sidebar: sidebar 
permalink: openshift/os-dp-tp-solution.html 
keywords: OpenShift, OCP, Trident, Trident-protect, NetApp ONTAP, Red Hat OpenShift, app data protection, Containers 
summary: Red Hat OpenShift 容器應用程式資料保護使用Trident和NetApp ONTAP進行保護 
---
= 使用Trident Protect 為 OpenShift 容器平台中的容器應用程式提供資料保護
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
參考文件的此部分提供了使用Trident保護建立容器應用程式的快照和備份的詳細資訊。  NetApp Trident Protect 提供進階應用程式資料管理功能，可增強由NetApp ONTAP儲存系統和NetApp Trident CSI 儲存設定器支援的有狀態 Kubernetes 應用程式的功能和可用性。  Trident Protect 會建立應用程式快照和備份，這意味著不僅建立持久磁碟區中的應用程式資料的快照和備份，還可以建立應用程式元資料的快照和備份。  Trident Protect 建立的快照和備份可以儲存在以下任何物件儲存中，並在稍後從中還原。

* AWS S3
* Azure Blob 儲存
* Google 雲端儲存
* Ontap S3
* 儲存網格
* 任何其他 S3 相容存儲


Trident Protect 使用基於角色的存取控制 (RBAC) 的 Kubernetes 模型。預設情況下， Trident Protect 提供一個名為 trident-protect 的單一系統命名空間及其關聯的預設服務帳戶。如果您的組織擁有許多使用者或特定的安全需求，您可以使用Trident Protect 的 RBAC 功能來更精細地控制對資源和命名空間的存取。

有關Trident Protect 中的 RBAC 的更多信息，請參閱link:https://docs.netapp.com/us-en/trident/trident-protect/manage-authorization-access-control.html["Trident保護文檔"]


NOTE: 叢集管理員可以存取預設的 trident-protect 命名空間中的資源，也可以存取所有其他命名空間中的資源。使用者無法在 trident-protect 命名空間中建立應用程式資料管理自訂資源 (CR)，如快照和備份 CR。作為最佳實踐，使用者需要在應用程式命名空間中建立這些 CR。

可依照文件中提供的說明安裝Trident Protectlink:https://docs.netapp.com/us-en/trident/trident-protect/trident-protect-installation.html["這裡"]本節將展示使用Trident Protect 對容器應用程式進行資料保護和復原應用程式的工作流程。1.快照建立（按需、按計畫）2.從快照恢復（恢復到相同和不同的命名空間）3.備份創建4.從備份還原

.先決條件
[%collapsible%open]
====
在為應用程式建立快照和備份之前，必須在Trident Protect 中配置物件儲存來儲存快照和備份。這是使用儲存桶 CR 完成的。只有管理員可以建立儲存桶 CR 並對其進行配置。在Trident Protect 中，儲存桶 CR 稱為 AppVault。  AppVault 物件是儲存桶的聲明性 Kubernetes 工作流程表示。  AppVault CR 包含儲存桶在保護作業（例如備份、快照、復原作業和SnapMirror複製）中所使用的必要配置。

在此範例中，我們將展示如何使用ONTAP S3 作為物件儲存。以下是為ONTAP S3 建立 AppVault CR 的工作流程： 1.在ONTAP叢集中的 SVM 中建立 S3 物件儲存伺服器。2.在物件儲存伺服器中建立一個儲存桶。3.在 SVM 中建立 S3 使用者。將存取密鑰和密鑰保存在安全的地方。4.在 OpenShift 中，建立一個金鑰來儲存ONTAP S3 憑證。5.為ONTAP S3 建立 AppVault 對象

**為ONTAP S3 設定Trident保護 AppVault**

***使用ONTAP S3 作為 AppVault 設定Trident Protect 的範例 yaml 檔案***

[source, yaml]
----
# alias tp='tridentctl-protect'

appvault-secret.yaml

apiVersion: v1
stringData:
  accessKeyID: "<access key id created for a user to access ONTAP S3 bucket>"
  secretAccessKey: "corresponding Secret Access Key"
#data:
# base 64 encoded values
#  accessKeyID: <base64 access key id created for a user to access ONTAP S3 bucket>
#  secretAccessKey: <base 64  Secret Access Key>
kind: Secret
metadata:
  name: appvault-secret
  namespace: trident-protect
type: Opaque

appvault.yaml

apiVersion: protect.trident.netapp.io/v1
kind: AppVault
metadata:
  name: ontap-s3-appvault
  namespace: trident-protect
spec:
  providerConfig:
    azure:
      accountName: ""
      bucketName: ""
      endpoint: ""
    gcp:
      bucketName: ""
      projectID: ""
    s3:
      bucketName: <bucket-name for storing the snapshots and backups>
      endpoint: <endpoint IP for S3>
      secure: "false"
      skipCertValidation: "true"
  providerCredentials:
    accessKeyID:
      valueFromSecret:
        key: accessKeyID
        name: appvault-secret
    secretAccessKey:
      valueFromSecret:
        key: secretAccessKey
        name: appvault-secret
  providerType: OntapS3

# oc create -f appvault-secret.yaml -n trident-protect
# oc create -f appvault.yaml -n trident-protect
----
image:rhhc-dp-tp-solution-container-001.png["AppVault 已建立"]

***用於安裝 postgresql 應用程式的範例 yaml 檔案***

[source, yaml]
----
postgres.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:14
        env:
        - name: POSTGRES_USER
          #value: "myuser"
          value: "admin"
        - name: POSTGRES_PASSWORD
          #value: "mypassword"
          value: "adminpass"
        - name: POSTGRES_DB
          value: "mydb"
        - name: PGDATA
          value: "/var/lib/postgresql/data/pgdata"
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pvc
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
---
apiVersion: v1
kind: Service
metadata:
  name: postgres
spec:
  selector:
    app: postgres
  ports:
  - protocol: TCP
    port: 5432
    targetPort: 5432
  type: ClusterIP

Now create the Trident protect application CR for the postgres app. Include the objects in the namespace postgres and create it in the postgres namespace.
# tp create app postgres-app --namespaces postgres -n postgres

----
image:rhhc-dp-tp-solution-container-002.png["應用程式已創建"]

====
.建立快照
[%collapsible%open]
====
**建立按需快照**

[source, yaml]
----

# tp create snapshot postgres-snap1 --app postgres-app --appvault ontap-s3-appvault -n postgres
Snapshot "postgres-snap1" created.

----
image:rhhc-dp-tp-solution-container-003.png["快照已建立"]

image:rhhc-dp-tp-solution-container-004.png["快照-pvc已創建"]

**建立計畫** 使用以下命令，將每天 15:33 建立快照，並保留兩個快照和備份。

[source, yaml]
----
# tp create schedule schedule1 --app postgres-app --appvault ontap-s3-appvault --backup-retention 2 --snapshot-retention 2 --granularity Daily --hour 15 --minute 33 --data-mover Restic -n postgres
Schedule "schedule1" created.
----
image:rhhc-dp-tp-solution-container-005.png["已創建 Schedule1"]

**使用 yaml 建立計劃**

[source, yaml]
----
# tp create schedule schedule2 --app postgres-app --appvault ontap-s3-appvault --backup-retention 2 --snapshot-retention 2 --granularity Daily --hour 15 --minute 33 --data-mover Restic -n postgres --dry-run > hourly-snapshotschedule.yaml

cat hourly-snapshotschedule.yaml

apiVersion: protect.trident.netapp.io/v1
kind: Schedule
metadata:
  creationTimestamp: null
  name: schedule2
  namespace: postgres
spec:
  appVaultRef: ontap-s3-appvault
  applicationRef: postgres-app
  backupRetention: "2"
  dataMover: Restic
  dayOfMonth: ""
  dayOfWeek: ""
  enabled: true
  granularity: Hourly
  #hour: "15"
  minute: "33"
  recurrenceRule: ""
  snapshotRetention: "2"
status: {}
----
image:rhhc-dp-tp-solution-container-006.png["已創建 Schedule2"]

您可以看到按照此計劃建立的快照。

image:rhhc-dp-tp-solution-container-007.png["Snap 按計畫創建"]

也創建了磁碟區快照。

image:rhhc-dp-tp-solution-container-008.png["PVC Snap 計畫完成"]

====
.刪除應用程式以模擬應用程式遺失
[%collapsible%open]
====
[source, yaml]
----
# oc delete deployment/postgres -n postgres
# oc get pod,pvc -n postgres
No resources found in postgres namespace.
----
====
.從快照還原到相同命名空間
[%collapsible%open]
====
[source, yaml]
----
# tp create sir postgres-sir --snapshot postgres/hourly-3f1ee-20250214183300 -n postgres
SnapshotInplaceRestore "postgres-sir" created.
----
image:rhhc-dp-tp-solution-container-009.png["先生創造"]

應用程式及其 PVC 恢復到同一個命名空間。

image:rhhc-dp-tp-solution-container-010.png["應用程式已恢復，先生"]

====
.從快照還原到不同的命名空間
[%collapsible%open]
====
[source, yaml]
----
# tp create snapshotrestore postgres-restore --snapshot postgres/hourly-3f1ee-20250214183300 --namespace-mapping postgres:postgres-restore -n postgres-restore
SnapshotRestore "postgres-restore" created.
----
image:rhhc-dp-tp-solution-container-011.png["snapRestore 已建立"]

您可以看到應用程式已還原到新的命名空間。

image:rhhc-dp-tp-solution-container-012.png["應用程式恢復，snapRestore"]

====
.建立備份
[%collapsible%open]
====
**建立按需備份**

[source, yaml]
----
# tp create backup postgres-backup1 --app postgres-app --appvault ontap-s3-appvault -n postgres
Backup "postgres-backup1" created.
----
image:rhhc-dp-tp-solution-container-013.png["備份已創建"]

**建立備份計畫**

上面列表中的每日和每小時備份是根據先前設定的計劃建立的。

[source, yaml]
----
# tp create schedule schedule1 --app postgres-app --appvault ontap-s3-appvault --backup-retention 2 --snapshot-retention 2 --granularity Daily --hour 15 --minute 33 --data-mover Restic -n postgres
Schedule "schedule1" created.
----
image:rhhc-dp-tp-solution-container-013-a.png["先前建立的時間表"]

====
.從備份中恢復
[%collapsible%open]
====
**刪除應用程式和 PVC 以模擬資料遺失。 **

image:rhhc-dp-tp-solution-container-014.png["先前建立的時間表"]

**恢復到相同的命名空間** #tp create bir postgres-bir --backup postgres/hourly-3f1ee-20250224023300 -n postgres BackupInplaceRestore "postgres-bir" created。

image:rhhc-dp-tp-solution-container-015.png["恢復到相同的命名空間"]

應用程式和 PVC 在同一個命名空間中恢復。

image:rhhc-dp-tp-solution-container-016.png["應用程式和 pvcs 恢復到同一個命名空間"]

**恢復到不同的命名空間** 建立一個新的命名空間。從備份還原到新的命名空間。

image:rhhc-dp-tp-solution-container-017.png["恢復到不同的命名空間"]

====
.遷移應用程式
[%collapsible%open]
====
若要將應用程式複製或遷移到不同的叢集（執行跨叢集克隆），請在來源叢集上建立備份，然後將備份還原到不同的叢集。確保目標叢集上安裝了Trident保護。

在來源叢集上，執行下圖所示的步驟：

image:rhhc-dp-tp-solution-container-018.png["恢復到不同的命名空間"]

從來源集群，將上下文切換到目標集群。然後，確保可以從目標群集上下文存取 AppVault，並從目標群集取得 AppVault 內容。

image:rhhc-dp-tp-solution-container-019.png["將上下文切換到目標"]

使用清單中的備份路徑並建立備份還原 CR 對象，如下面的命令所示。

[source, yaml]
----
# tp create backuprestore backup-restore-cluster2 --namespace-mapping postgres:postgres --appvault ontap-s3-appvault --path postgres-app_4d798ed5-cfa8-49ff-a5b6-c5e2d89aeb89/backups/postgres-backup-cluster1_ec0ed3f3-5500-4e72-afa8-117a04a0b1c3 -n postgres
BackupRestore "backup-restore-cluster2" created.
----
image:rhhc-dp-tp-solution-container-020.png["恢復至目標"]

現在您可以看到應用程式 pod 和 PVC 已在目標叢集中建立。

image:rhhc-dp-tp-solution-container-021.png["目標叢集上的應用程式"]

====